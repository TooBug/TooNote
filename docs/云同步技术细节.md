## 版本结构

整体设计类似于Git版本控制，每一个版本类似Git中的一个Commit。每一个版本包含多个笔记的变更。

Version的Schema设计如下：

```javascript
export default {
	name: 'Version',
	primaryKey: 'id',
	properties: {
		id: 'string',
		message: 'string',
		createdAt: 'date',
		updatedAt: 'date',
		notes: 'Note[]',
		categories: 'Category[]',
		notebooks: 'Notebooks[]',
		changes: 'string'
	}
};
```

其中`notes` `categories` `notebooks`用来引用相关的笔记、分类、笔记本，主要作用是为了快速查找某个对象的所有历史版本（读取反向关联中的`versions`即可）。

具体的变量记录在`changes`中，是一个序列化的数组。

```javascript
changes = [change,...];

change = {
    action: 'create|edit|delete',
    targetType: 'Note|Category|Notebook',
    targetId: 'xxxxxx',
    data: {
        title: 'abc',
        categoryId: 'xxxxxx'
    }
};
```

`type`值的说明：

- `Note|Category|Notebook` 说明变更的是笔记、分类、笔记本，`data`记录变更后的字段内容

服务端保留所有版本，为中心，出现冲突时以服务端为准，其它端在服务端的基础上解决冲突。

客户端不保留所有版本（后续可能会定期清理），仅保留最近的版本。

## 版本同步逻辑

客户端记录上一次同步成功的版本号（类似Git的remote branch），起一个名字，叫“共识版本”。

这个共识版本号之后所有的版本记录不会被清理，确保有共识版本到目前为止所有的版本。

### step1 客户端报告版本

客户端向服务端报告自己的共识版本。

### step2 服务端确认是否有更新的版本

如果有更新版本，则发送这些版本的列表。

### step3 客户端更新服务端版本

客户端从共识版本开始，依次拉取版本的变更情况，将涉及的笔记本、分类、笔记一一拉取回来更新到本地。设定新的共识版本为最新同步的版本。

### step4 客户端更新本地版本序列

将共识版本之后的版本的父版本设为最新的共识版本，然后再重新应用本地的变更。（类似Git的rebase流程）

如果有冲突的话，首先尝试自动合并，如果合并失败，则提示用户进行合并。（todo:rebase合并冲突可能有很多次，是否在用户介入时减少合并次数？）

### step5 客户端向服务端发送新版本记录

客户端向服务端发送共识版本之后的版本，服务端进行更新。成功则将共识版本标为最新版本。如果失败（step2 - step5之间有时间差），则标识为同步失败，一段时间后重新开始同步。
